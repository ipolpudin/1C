////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                
                                                                                                                        Транзацкии

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Рекомендуется использовать открытие пакета транзакции, так как запись в SQL будет происходить пакетом за один раз.
// Например: можно сделать запись справочника, затем РС, затем документа - будет 3 транзакции, 3 обращения к серверу на запись.
// Или объеденить запись справочника, РС, документа в одну транзакцию - будет 1 транзакция, 1 обращения к серверу на запись.

Заказ.Записать(); - Запись происходит в транзакции

Методы формирования транзакций:
1) Запись единичной транзакции
Заказ.Записать(); - первая транзакция
Приобретение.Записать(); - вторая транзакция

2) Открытие пакета транзакции(объединение нескольких транзакций в одну)
Процедура ЗаписатьДанныеВИБ()

    НачатьТранзакцию();

    Попытка
        ... // все происходит в рамках одной транзакции
        ДокументОбъект.Записать() все происходит в рамках одной транзакции
        ЗафиксироватьТранзакцию(); все происходит в рамках одной транзакции
    Исключение
        ОтменитьТранзакцию();
        ... // дополнительные действия по обработке исключения
    КонецПопытки;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                Явная
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Описывается вручную

НачатьТранзакцию();

Попытка
      ... // все происходит в рамках одной транзакции
        ДокументОбъект.Записать() все происходит в рамках одной транзакции
        ЗафиксироватьТранзакцию(); все происходит в рамках одной транзакции
    Исключение
        ОтменитьТранзакцию();
        ... // дополнительные действия по обработке исключения
КонецПопытки;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                               Неявная
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Создается при создании элемента через пользовательский режим (в событиях перед записью и т.д.)
При работе через встроенный язык Объект.Записать()
При чтении данных. Для разных SQL и читаемых объектов по разному

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                                                                              
                                                                                                                    Чтение
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
В открытых транзакциях читаются только данные не заблокированные данные, заблокированные с режимом блокировки распределенной, измененный данные с зафиксированной транзакцией (при вызове функции Записать() накладывается исключительная блокировка) 

///////////////////////////////////////////////////////////////////////////////////////////////////
                                    Грязное чтение
///////////////////////////////////////////////////////////////////////////////////////////////////
Чтение вне транзакций и блокировок, может читать измененные объекты в незафиксированных транзакциях (ЗафиксироватьТранзакцию())
Практическим проверять на каждой базе возможность грязного чтения на данных с ТЧ и без ТЧ.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                 Ответственное чтение
///////////////////////////////////////////////////////////////////////////////////////////////////
https://its.1c.ru/db/v8std/content/648/hdoc

Решает проблемы:
1) Чтение половины актуальных, половину устаревших данных (у документа изменился реквизит, а РС еще нет)
2) Незафиксированрых транзакций
3) Чтение актуальных данных

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                
                                                                                                                    Практические правила

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
Анализ взаимоблокировок https://its.1c.ru/db/metod8dev#content:4051:hdoc:case1_3


При обмене: 
Все изменение и создания делать в одной транзакции

1) Обычный поиск по ключам или идентификатору выполнять вне транзакций и блокировок (если нет эффекта чтения из незафиксированных транзакций).

2) Получение реквизитов найденного элемента.
Если изменении реквизита у найденного объекта окажет влияние на создаваемый документ.
Нужно ответить на вопрос: 
Что будет если изменить этот реквизит после создания документа?
Если ли здесь вероятность прочитать половину актуальных и половину устаревших данных например у документа изменились реквизиты, а записи РС еще нет?
При необходимости включить Ответственное чтение.

3) Чтение дочернего элемента, и изменение/созданию этого дочернего элемента по условию прочитанных данных
Дочернего элемента может не быть
По условию от реквизита дочернего элемента требуется изменение
По условию от реквизита дочернего элемента не требуется изменение

Чтение осуществлять по логике из пунктов 1 и 2. 
При выявлении использования распределенной блокировки и дальнейшем изменение элемента снимать распределенную блокировки и стравить исключительную с дальнейшей проверкой (избегание взаимоблокировок). 
Особое внимание на  "Что если обмен в фоне и происходит создание одинаковых дочерних элементов в разных фоновых заданиях"

4) Создание основных элементов и дочерних. 
Решение проблемы "Что если обмен в фоне и происходит создание одинаковых дочерних элементов в разных фоновых заданиях":
4.1)  Один поток создает один элемент. Одинаковые потоки происходят последовательно
4.2)  Один поток создает много элементов. Все потоки происходят последовательно

5) При поиске в РС Соответствия элементов обмена с другиими базами

Что может быть если не пользоваться транзакциями и блокировками
1) Читать незафиксированные транзакции (в разных СУБД по разному)
2) Читать изменяемые данные
3) Читать половину актуальных половину устаревший данных (документ и РС)
4) Создание в разных фоновых заданиях одинаковых элементов (искали по инн, не нашли и создали элемент), но эти действия произошли в двух фоновых заданиях


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                
                                                                                                                        Блокировки

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                    //СправочнаяИнформация
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//https://www.youtube.com/watch?v=5z7c7pH68R0&t=2s
Эскалация - Когда системе проще заблокировать не 5000 записей, а целеком всю таблицу
Взаимоблокировки - когда 2 блокировки ставят (S)блокировку, а потом пытаются поставть (X)блокировку. Предпочтение отдается той блокировке которая успела сделать большее количество записей.
А другую блокировку с меньшим количеством записей откатывают назад

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                    //Блокировка на Уровне СУБД
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
!!!Блокировки ведутся только в транзакциях


Блокировки ведутся на стороне СУБД в таблице.
Проверяется в бесконечном цикле разрешено менять статус или передавать блокировку
Номер|Тип Блокировки |Ресурс 
...  |...            |...


//https://www.youtube.com/watch?v=5QoFKGBH8Xk
//Читаем(S)
//Меняем(X)
//Намерение(IS)
//ЧтениеСПоследующимИзменением(U)

Тип блокировки на стороне СУБД | ПотерянноеОбновление |ГрязныеЧтение |НеповторяемоеЧтение | ЧтениеФантомов | Читаем(S)               | Меняем(X)
READ UNCOMMITED                         +                   -               -                     -          нет                       да, и сразу мнимаем
READ COMMITED                           +                   +               -                     -          да и сразу снимаеи        да, до конца
READ COMMITED SNAPSHOP(Снимок)          +                   +               +                     -          нет, отправляем снимок    да, до конца
REPEATABLE READ                         +                   +               +                     -          да, до конца              да, до конца
SERIALIZABLE                            +                   +               +                     +          да, до конца              да, до конца

Есть 2 Вида режима установки Блокировки
1) Автоматическая - Отвечает СУБД, отображается в таблице блокировок СУБД
Тип - REPEATABLE READ 
Снижает производительность в высоконагруженной сети
2) Управляемая    - Отвечает Сервер Приложения, отображается в таблице блокировок СУБД
Тип - READ COMMITED
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
                                                                                                                    //Блокировка Объектная
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ОбъектнаяБлокировка происходит на уровне Сервера Приложения, и не отностится к СУБД.
В частности блокировка накладывается на форму
1) Пессимистическая.
Если элементы формы изменились(Мотифицированность = ИСТИНА), то на эту форму накладывается блокировка на Запись и попытку заблокировать данные
2) Оптимистическая. 
Проверка осуществляется при попытке записать. Если этот же объект отредактирован другим пользователем, то будет уведомление о неактуальности данных
Не работает с Регистрами сведений и т.д, потому что у них нет поля Версия в СУБД 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
                                                                                                                    //Блокировка Транзакционная
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Выполняется на Уровне Сервера 1С, НЕ отображается в таблице блокировок СУБД
//{?
Когда Пользователь №1 наложил блокировку из документа Приход(с блокировкий) другой пользователь открывающий документ Приход 
или работающий с элементами устанавливающими отбор тоже получат запрет на Чтение/Запись.
А на обчный запрос обращающийся к заблокированным данным это не отностся, он сможет безпрепятственно прочитать заблокированные данные.
Но если перед запросом в транзакции устанавливается блокировка, то запрос не сможет взять заблокированные данные.
(Повидимому тогда происходит сверка Намерения(IS) и возможности это сделать)
//}?

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                    //РазделениеИтогов РегистраНакопления
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Два разных документа проводят в один регистр сведения проводки. Регистраторы разные.
В табле Итогов нет разделения на регистраторы, поэтому блокируется по индексируемым полям(Номенклатура)
Поэтому при проведение разных документов будет происходить ожидание.
Решение: ВКЛ в конфигураторе и в 1С Предприятии режим разделения Таблицы итогов, тогда добавиться сплитер.
Минусы: Таблицу итогов придется переодически пересчитывать для бы в один день по одной Номенклатуре не происходили дублированяи из-за Сплитеров
